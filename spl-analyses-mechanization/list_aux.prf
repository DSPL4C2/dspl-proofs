(list_aux_map
 (map_syntax 0
  (map_syntax-1 nil 3788027745
   ("" (induct l)
    (("1" (expand map) (("1" (propax) nil nil)) nil)
     ("2" (skosimp + head tail)
      (("2" (skeep)
        (("2" (inst? -)
          (("2" (expand map +) (("2" (decompose-equality 1) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_cons_extensionality formula-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T1 formal-type-decl nil list_aux_map nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T2 formal-type-decl nil list_aux_map nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (map_extensionality 0
  (map_extensionality-1 nil 3788032281
   ("" (induct l)
    (("1" (expand map) (("1" (propax) nil nil)) nil)
     ("2" (skosimp + head tail)
      (("2" (skeep :preds? t)
        (("2" (inst - f1 f2)
          (("2" (expand map +)
            (("2" (decompose-equality 1)
              (("1" (inst - "cons1_var!1")
                (("1" (expand member) (("1" (propax) nil nil)) nil))
                nil)
               ("2" (skeep :preds? t)
                (("2" (inst?)
                  (("2" (expand member +) (("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons2_var!1 skolem-const-decl "list[T1]" list_aux_map nil)
    (cons1_var!1 skolem-const-decl "T1" list_aux_map nil)
    (m skolem-const-decl "{m: T1 | member(m, cons2_var!1)}"
     list_aux_map nil)
    (list_induction formula-decl nil list_adt nil)
    (T1 formal-type-decl nil list_aux_map nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T2 formal-type-decl nil list_aux_map nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak)))
(list_aux_map_props
 (map_composition 0
  (map_composition-1 nil 3788027834
   ("" (skeep)
    (("" (use "map_syntax[T2, T3]")
      (("" (rewrite - :dir RL)
        (("" (use "map_list_composition[T1, T2, T3]")
          (("" (rewrite "map_syntax[T1, T2]" :dir RL)
            (("" (rewrite "map_syntax[T1, T3]" :dir RL) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((map_syntax formula-decl nil list_aux_map nil)
    (T2 formal-type-decl nil list_aux_map_props nil)
    (T3 formal-type-decl nil list_aux_map_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (T1 formal-type-decl nil list_aux_map_props nil)
    (list type-decl nil list_adt nil)
    (map_list_composition formula-decl nil map_props nil)
    (O const-decl "T3" function_props nil))
   shostak)))
(list_map_type_compatibility
 (type_conformance 0
  (type_conformance-1 nil 3788029893
   ("" (induct l)
    (("1" (expand every) (("1" (propax) nil nil)) nil)
     ("2" (skosimp + head tail)
      (("2" (skeep :preds? t)
        (("2" (expand every +)
          (("2" (inst - f)
            (("2" (inst-cp - "cons1_var!1")
              (("1" (assert)
                (("1" (split)
                  (("1" (propax) nil nil)
                   ("2" (skeep :preds? t)
                    (("2" (inst - m)
                      (("2" (expand member +) (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand member) (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons1_var!1 skolem-const-decl "T1" list_map_type_compatibility
     nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons2_var!1 skolem-const-decl "list[T1]"
     list_map_type_compatibility nil)
    (m skolem-const-decl "{m: T1 | member(m, cons2_var!1)}"
     list_map_type_compatibility nil)
    (list_induction formula-decl nil list_adt nil)
    (T1 formal-type-decl nil list_map_type_compatibility nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (TT1_pred const-decl "[T1 -> boolean]" list_map_type_compatibility
     nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T2 formal-type-decl nil list_map_type_compatibility nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (map_type_compatibility_TCC1 0
  (map_type_compatibility_TCC1-1 nil 3788029422
   ("" (induct l)
    (("1" (expand every) (("1" (propax) nil nil)) nil)
     ("2" (skosimp + head tail)
      (("2" (skeep :preds? t)
        (("2" (expand every +)
          (("2" (inst - f)
            (("2" (inst-cp - "cons1_var!1")
              (("1" (assert)
                (("1" (split)
                  (("1" (propax) nil nil)
                   ("2" (skeep :preds? t)
                    (("2" (inst - m)
                      (("2" (expand member +) (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand member) (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons1_var!1 skolem-const-decl "T1" list_map_type_compatibility
     nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons2_var!1 skolem-const-decl "list[T1]"
     list_map_type_compatibility nil)
    (m skolem-const-decl "{m: T1 | member(m, cons2_var!1)}"
     list_map_type_compatibility nil)
    (list_induction formula-decl nil list_adt nil)
    (T1 formal-type-decl nil list_map_type_compatibility nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (TT1_pred const-decl "[T1 -> boolean]" list_map_type_compatibility
     nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T2 formal-type-decl nil list_map_type_compatibility nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (map_type_compatibility 0
  (map_type_compatibility-1 nil 3788029678
   ("" (induct l)
    (("1" (expand map) (("1" (propax) nil nil)) nil)
     ("2" (skosimp + head tail)
      (("2" (skeep :preds? t)
        (("2" (inst? -)
          (("2" (expand map +)
            (("2" (expand restrict + 1)
              (("2" (decompose-equality 1)
                (("2" (skeep :preds? t)
                  (("2" (inst? -)
                    (("2" (expand member +) (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (use type_conformance) nil nil)) nil))
    nil)
   ((type_conformance formula-decl nil list_map_type_compatibility nil)
    (cons1_var!1 skolem-const-decl "T1" list_map_type_compatibility
     nil)
    (m skolem-const-decl "{m: T1 | member(m, cons2_var!1)}"
     list_map_type_compatibility nil)
    (cons2_var!1 skolem-const-decl "list[T1]"
     list_map_type_compatibility nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T1 formal-type-decl nil list_map_type_compatibility nil)
    (restrict const-decl "R" restrict nil)
    (TT1 formal-subtype-decl nil list_map_type_compatibility nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (T2 formal-type-decl nil list_map_type_compatibility nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (TT1_pred const-decl "[T1 -> boolean]" list_map_type_compatibility
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil))
   shostak)))

